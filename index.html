<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Gerador de Decalque — OrienteTattooApp</title>
  <style>
    body { font-family: Arial, sans-serif; background:#111; color:#fff; text-align:center; padding:32px; }
    input, textarea, button, select {
      width:100%; max-width:420px; margin:10px auto; padding:12px;
      border-radius:8px; border:none; font-size:16px; display:block;
    }
    button { background:#25D366; color:#0b1a12; cursor:pointer; font-weight:bold; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    #loader { display:none; margin:12px auto 0; max-width:420px; font-size:14px; opacity:.9; }
    #erro { display:none; margin:12px auto 0; max-width:420px; background:rgba(255,0,85,.15);
      border:1px solid rgba(255,0,85,.4); padding:10px; border-radius:10px; text-align:left; font-size:14px; white-space:pre-wrap; }
    img { max-width:420px; width:100%; margin-top:18px; border-radius:12px; background:#fff; }
    .hint { max-width:420px; margin:6px auto 0; font-size:12px; opacity:.75; }

    /* Caixa cooldown */
    #cooldownBox{
      display:none; margin:14px auto 0; max-width:420px;
      background:rgba(255, 210, 0, .12);
      border:1px solid rgba(255, 210, 0, .35);
      padding:12px; border-radius:12px; text-align:left;
    }

    /* ===== Comparador antes/depois (ARRASTÁVEL) ===== */
    .ot-compare-wrap{
      width:100%;
      max-width:420px;
      margin: 18px auto 0;
    }
    .ot-compare{
      position:relative;
      width:100%;
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      user-select:none;
      touch-action: pan-y; /* permite scroll vertical no mobile */
    }
    .ot-compare img{
      width:100%;
      height:auto;
      display:block;
      -webkit-user-drag:none;
      user-select:none;
      pointer-events:none; /* importante: dedo não “pega” a imagem */
      background:#fff;
    }
    .ot-compare .ot-after{
      position:absolute;
      inset:0;
      width:50%;
      overflow:hidden;
    }
    .ot-compare .ot-label{
      position:absolute;
      top:10px;
      z-index:8;
      font-size:12px;
      font-weight:800;
      letter-spacing:.06em;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.55);
      color:#fff;
      backdrop-filter: blur(6px);
      pointer-events:none;
    }
    .ot-compare .ot-label.before{ left:10px; }
    .ot-compare .ot-label.after{ right:10px; }

    .ot-compare .ot-line{
      position:absolute;
      top:0;
      left:50%;
      transform: translateX(-50%);
      width:4px;
      height:100%;
      background:#00ff66;
      box-shadow: 0 0 14px rgba(0,255,102,.75);
      border-radius:999px;
      z-index:6;
      pointer-events:none;
    }
    .ot-compare .ot-slider{
      position:absolute;
      top:0;
      left:50%;
      transform: translateX(-50%);
      height:100%;
      width:52px;
      z-index:7;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: ew-resize;

      /* trava o comportamento do dedo no puxador */
      touch-action: none;
    }
    .ot-compare .ot-knob{
      position:relative;
      background:#00ff66;
      color:#0b1a12;
      font-weight:900;
      border-radius:999px;
      padding:8px 12px;
      font-size:14px;
      line-height:1;
      box-shadow: 0 0 18px rgba(0,255,102,.75);
    }

    /* Botões de ação (opcional, estilo simples) */
    .actions{
      max-width:420px;
      margin: 10px auto 0;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .actions button{
      width:auto;
      max-width:none;
      padding:10px 14px;
      border-radius:10px;
      border:none;
      background:#2b6cff;
      color:#fff;
      font-weight:800;
    }
    .actions button.secondary{ background:#444; }
    .actions button.tertiary{ background:#25D366; color:#0b1a12; }
  </style>
</head>
<body>

  <h1>Gerador de Decalque</h1>
  <div class="hint">Limite de uso: <b>20 gerações</b>. Ao atingir, aguarde <b>40 minutos</b> e libera novamente.</div>

  <input type="file" id="image" accept="image/*" />

  <select id="style">
    <option value="line">Modo 1 — Decalque linhas (line art puro)</option>
    <option value="shadow">Modo 2 — Linhas + sombra leve</option>
    <option value="clean" selected>Modo 3 — Tatuagem → desenho clean</option>
  </select>

  <textarea id="prompt" placeholder="(Opcional) Observações: ex: traço fino, completar parte escondida..."></textarea>

  <button id="btnGerar">Gerar Decalque</button>

  <div id="loader">⏳ Gerando... (não feche a página)</div>
  <div id="erro"></div>

  <div id="cooldownBox"></div>

  <div id="resultado"></div>

  <script>
    const btn = document.getElementById("btnGerar");
    const loader = document.getElementById("loader");
    const erroBox = document.getElementById("erro");
    const resultado = document.getElementById("resultado");
    const cooldownBox = document.getElementById("cooldownBox");

    // Config
    const MAX_FILE_MB = 6;
    const MAX_W = 1200;
    const JPEG_QUALITY = 0.86;
    const API_TIMEOUT_MS = 60000;

    // Endpoint (mesmo projeto Vercel)
    const API_URL = "/api/generate";

    function showError(msg) {
      erroBox.style.display = "block";
      erroBox.textContent = msg;
    }
    function clearError() {
      erroBox.style.display = "none";
      erroBox.textContent = "";
    }
    function showCooldown(msgHtml){
      cooldownBox.style.display = "block";
      cooldownBox.innerHTML = msgHtml;
    }
    function hideCooldown(){
      cooldownBox.style.display = "none";
      cooldownBox.innerHTML = "";
    }

    function getDeviceId() {
      const key = "__ot_device_id__";
      let id = localStorage.getItem(key);
      if (!id) {
        id = (crypto?.randomUUID?.() || ("dev_" + Math.random().toString(16).slice(2) + Date.now()));
        localStorage.setItem(key, id);
      }
      return id;
    }

    // Opcional: se você usar ?uid= no link, trava por conta em qualquer dispositivo
    function getUserId() {
      const key = "__ot_user_id__";
      const params = new URLSearchParams(location.search);
      const uidFromUrl = (params.get("uid") || "").trim();

      if (uidFromUrl) {
        localStorage.setItem(key, uidFromUrl);
        return uidFromUrl;
      }
      return (localStorage.getItem(key) || "").trim();
    }

    async function fileToBase64Compressed(file) {
      const img = await new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const i = new Image();
        i.onload = () => { URL.revokeObjectURL(url); resolve(i); };
        i.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error("Não consegui ler a imagem. Se for iPhone (HEIC), converta para JPG e tente novamente."));
        };
        i.src = url;
      });

      let w = img.naturalWidth || img.width;
      let h = img.naturalHeight || img.height;
      if (!w || !h) throw new Error("Imagem inválida.");

      if (w > MAX_W) {
        const ratio = MAX_W / w;
        w = Math.round(w * ratio);
        h = Math.round(h * ratio);
      }

      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;

      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, w, h);

      const dataUrl = canvas.toDataURL("image/jpeg", JPEG_QUALITY);
      return { base64: dataUrl.split(",")[1], mimeType: "image/jpeg" };
    }

    function secondsToMinSec(s){
      const m = Math.floor(s/60);
      const r = s % 60;
      return `${m}m ${String(r).padStart(2,"0")}s`;
    }

    // ===== Comparador antes/depois (helpers) =====
    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }

    function mountCompare(beforeSrc, afterSrc){
      // limpa área e recria
      resultado.innerHTML = "";

      const wrap = document.createElement("div");
      wrap.className = "ot-compare-wrap";

      wrap.innerHTML = `
        <div class="ot-compare" id="otCompare" aria-label="Comparador antes e depois">
          <span class="ot-label before">ANTES</span>
          <span class="ot-label after">DEPOIS</span>

          <img id="beforeImg" alt="Antes">
          <div class="ot-after" id="afterOverlay">
            <img id="afterImg" alt="Depois">
          </div>

          <div class="ot-line" id="compareLine"></div>
          <div class="ot-slider" id="compareSlider" aria-label="Arraste para comparar">
            <div class="ot-knob">⇆</div>
          </div>
        </div>
      `;

      // Mantém uma img “original” escondida (compatibilidade / download)
      const hiddenResult = document.createElement("img");
      hiddenResult.id = "resultImg";
      hiddenResult.style.display = "none";

      // Botões (download e gerar de novo / reset)
      const actions = document.createElement("div");
      actions.className = "actions";
      actions.innerHTML = `
        <button id="downloadBtn">Baixar</button>
        <button id="againBtn" class="secondary">Gerar novamente</button>
        <button id="resetBtn" class="tertiary">Começar de novo</button>
      `;

      resultado.appendChild(wrap);
      resultado.appendChild(hiddenResult);
      resultado.appendChild(actions);

      const otCompare = document.getElementById("otCompare");
      const afterOverlay = document.getElementById("afterOverlay");
      const compareSlider = document.getElementById("compareSlider");
      const compareLine = document.getElementById("compareLine");
      const beforeImg = document.getElementById("beforeImg");
      const afterImg = document.getElementById("afterImg");
      const resultImg = document.getElementById("resultImg");

      beforeImg.src = beforeSrc;
      afterImg.src = afterSrc;
      resultImg.src = afterSrc; // base para download

      function setComparePositionByPercent(pct){
        const p = clamp(pct, 0, 100);
        afterOverlay.style.width = p + "%";
        compareSlider.style.left = p + "%";
        compareLine.style.left = p + "%";
      }

      // Arrasto horizontal perfeito: só pelo puxador
      (function initCompareDrag(){
        let dragging = false;

        const getPercentFromClientX = (clientX) => {
          const rect = otCompare.getBoundingClientRect();
          const x = clamp(clientX - rect.left, 0, rect.width);
          return (x / rect.width) * 100;
        };

        compareSlider.addEventListener("pointerdown", (e) => {
          dragging = true;
          compareSlider.setPointerCapture(e.pointerId);
          e.preventDefault();
          setComparePositionByPercent(getPercentFromClientX(e.clientX));
        });

        compareSlider.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          e.preventDefault();
          setComparePositionByPercent(getPercentFromClientX(e.clientX));
        });

        compareSlider.addEventListener("pointerup", (e) => {
          dragging = false;
          try { compareSlider.releasePointerCapture(e.pointerId); } catch {}
        });

        compareSlider.addEventListener("pointercancel", (e) => {
          dragging = false;
          try { compareSlider.releasePointerCapture(e.pointerId); } catch {}
        });

        setComparePositionByPercent(50);
      })();

      // Ações
      document.getElementById("downloadBtn").onclick = () => {
        const a = document.createElement("a");
        a.href = resultImg.src;
        a.download = "decalque.png";
        a.click();
      };
      document.getElementById("againBtn").onclick = () => {
        // só limpa o resultado pra gerar outra sem recarregar a página
        resultado.innerHTML = "";
      };
      document.getElementById("resetBtn").onclick = () => location.reload();
    }

    // ===== FALLBACK LOCAL (quando a API falhar / IA bloquear) =====
    async function generateLocalStencilDataURL(sourceImgElOrSrc, mode = "line") {
      const img = await new Promise((resolve, reject) => {
        if (typeof sourceImgElOrSrc !== "string") {
          if (sourceImgElOrSrc.complete && sourceImgElOrSrc.naturalWidth) return resolve(sourceImgElOrSrc);
          sourceImgElOrSrc.onload = () => resolve(sourceImgElOrSrc);
          sourceImgElOrSrc.onerror = () => reject(new Error("Falha ao carregar imagem (fallback)."));
          return;
        }
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = () => reject(new Error("Falha ao carregar imagem (fallback)."));
        i.src = sourceImgElOrSrc;
      });

      const cfg = {
        line:   { blur: 1, edgeBoost: 1.35, thresh: 90,  dilate: 0 },
        shadow: { blur: 2, edgeBoost: 1.10, thresh: 70,  dilate: 0 },
        clean:  { blur: 2, edgeBoost: 1.25, thresh: 85,  dilate: 1 },
      }[mode] || { blur: 1, edgeBoost: 1.35, thresh: 90, dilate: 0 };

      // mantém padrão MAX_W
      let w = img.naturalWidth || img.width;
      let h = img.naturalHeight || img.height;
      if (!w || !h) throw new Error("Imagem inválida (fallback).");

      const MAX_W_LOCAL = 1200;
      if (w > MAX_W_LOCAL) {
        const r = MAX_W_LOCAL / w;
        w = Math.round(w * r);
        h = Math.round(h * r);
      }

      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);

      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;

      // grayscale
      const gray = new Uint8ClampedArray(w * h);
      for (let i = 0, p = 0; i < data.length; i += 4, p++) {
        gray[p] = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) | 0;
      }

      const blurred = (cfg.blur > 0) ? boxBlurGray(gray, w, h, cfg.blur) : gray;
      const edges = sobelEdges(blurred, w, h, cfg.edgeBoost);

      // threshold -> preto no branco
      const out = ctx.createImageData(w, h);
      const outD = out.data;
      for (let p = 0, i = 0; p < edges.length; p++, i += 4) {
        const v = edges[p] > cfg.thresh ? 0 : 255;
        outD[i] = v; outD[i + 1] = v; outD[i + 2] = v; outD[i + 3] = 255;
      }

      if (cfg.dilate > 0) {
        dilateBinary(out, w, h, cfg.dilate);
      }

      ctx.putImageData(out, 0, 0);
      return canvas.toDataURL("image/png");
    }

    function boxBlurGray(src, w, h, radius) {
      const dst = new Uint8ClampedArray(src.length);
      const r = Math.max(1, radius);

      // horizontal
      const tmp = new Uint8ClampedArray(src.length);
      for (let y = 0; y < h; y++) {
        let sum = 0;
        const row = y * w;
        for (let x = -r; x <= r; x++) {
          const ix = Math.min(w - 1, Math.max(0, x));
          sum += src[row + ix];
        }
        for (let x = 0; x < w; x++) {
          tmp[row + x] = (sum / (2 * r + 1)) | 0;
          const xRemove = Math.max(0, x - r);
          const xAdd = Math.min(w - 1, x + r + 1);
          sum += src[row + xAdd] - src[row + xRemove];
        }
      }

      // vertical
      for (let x = 0; x < w; x++) {
        let sum = 0;
        for (let y = -r; y <= r; y++) {
          const iy = Math.min(h - 1, Math.max(0, y));
          sum += tmp[iy * w + x];
        }
        for (let y = 0; y < h; y++) {
          dst[y * w + x] = (sum / (2 * r + 1)) | 0;
          const yRemove = Math.max(0, y - r);
          const yAdd = Math.min(h - 1, y + r + 1);
          sum += tmp[yAdd * w + x] - tmp[yRemove * w + x];
        }
      }
      return dst;
    }

    function sobelEdges(gray, w, h, boost = 1.0) {
      const out = new Uint8ClampedArray(gray.length);
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const i = y * w + x;

          const gx =
            -gray[i - w - 1] + gray[i - w + 1] +
            -2 * gray[i - 1]   + 2 * gray[i + 1] +
            -gray[i + w - 1] + gray[i + w + 1];

          const gy =
            -gray[i - w - 1] - 2 * gray[i - w] - gray[i - w + 1] +
             gray[i + w - 1] + 2 * gray[i + w] + gray[i + w + 1];

          const mag = Math.min(255, (Math.hypot(gx, gy) * boost) | 0);
          out[i] = mag;
        }
      }
      return out;
    }

    function dilateBinary(imageData, w, h, radius = 1) {
      const d = imageData.data;
      const copy = new Uint8ClampedArray(d);
      const r = Math.max(1, radius);

      const isBlack = (idx) => copy[idx] === 0;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          if (copy[i] === 0) continue;

          let makeBlack = false;
          for (let dy = -r; dy <= r && !makeBlack; dy++) {
            const yy = y + dy;
            if (yy < 0 || yy >= h) continue;
            for (let dx = -r; dx <= r; dx++) {
              const xx = x + dx;
              if (xx < 0 || xx >= w) continue;
              const j = (yy * w + xx) * 4;
              if (isBlack(j)) { makeBlack = true; break; }
            }
          }

          if (makeBlack) {
            d[i] = d[i + 1] = d[i + 2] = 0;
            d[i + 3] = 255;
          }
        }
      }
    }

    async function gerar() {
      clearError();
      hideCooldown();
      resultado.innerHTML = "";

      const file = document.getElementById("image").files[0];
      const style = document.getElementById("style").value;
      const prompt = (document.getElementById("prompt").value || "").trim();

      if (!file) {
        showError("Envie uma imagem primeiro.");
        return;
      }

      const mb = file.size / (1024 * 1024);
      if (mb > MAX_FILE_MB) {
        showError(`Arquivo muito grande (${mb.toFixed(2)}MB). Use até ${MAX_FILE_MB}MB.`);
        return;
      }

      btn.disabled = true;
      const oldText = btn.textContent;
      btn.textContent = "Gerando...";
      loader.style.display = "block";

      let beforeSrc = "";
      try {
        // preview do upload (ANTES) – usa blob local
        beforeSrc = URL.createObjectURL(file);

        const { base64: imageBase64, mimeType } = await fileToBase64Compressed(file);

        const deviceId = getDeviceId();
        const userId = getUserId();

        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), API_TIMEOUT_MS);

        const headers = {
          "Content-Type": "application/json",
          "X-Device-Id": deviceId
        };
        if (userId) headers["X-User-Id"] = userId;

        const res = await fetch(API_URL, {
          method: "POST",
          headers,
          signal: controller.signal,
          body: JSON.stringify({ imageBase64, mimeType, style, prompt })
        });

        clearTimeout(t);
        const data = await res.json().catch(() => ({}));

        // Cooldown (mantido como está)
        if (res.status === 429 && data?.code === "COOLDOWN") {
          const retry = Number(data.retry_after_seconds || 0);
          showCooldown(
            `<b>Limite temporário atingido.</b><br><br>` +
            `Aguarde <b>${secondsToMinSec(retry)}</b> e tente novamente.<br>` +
            `Você usou <b>${data.used ?? 20}/${data.limit ?? 20}</b> neste lote.`
          );
          return;
        }

        // ✅ Se a API falhar / não vier imagem => FALLBACK LOCAL (sem erro pro cliente)
        if (!res.ok || !data.imageBase64) {
          const afterSrc = await generateLocalStencilDataURL(beforeSrc, style);
          mountCompare(beforeSrc, afterSrc);
          return;
        }

        const afterSrc = "data:image/png;base64," + data.imageBase64;
        mountCompare(beforeSrc, afterSrc);

      } catch (err) {
        // ✅ Se a requisição der erro (timeout/500/etc), tenta fallback local antes de mostrar erro
        try {
          if (beforeSrc) {
            const style = document.getElementById("style").value;
            const afterSrc = await generateLocalStencilDataURL(beforeSrc, style);
            mountCompare(beforeSrc, afterSrc);
            return;
          }
        } catch {}

        const isTimeout = err && (err.name === "AbortError" || String(err.message || "").toLowerCase().includes("abort"));
        showError("Erro: " + (isTimeout ? "Tempo excedido. Tente novamente." : (err?.message || String(err))));
      } finally {
        loader.style.display = "none";
        btn.disabled = false;
        btn.textContent = oldText;

        // limpa blob
        if (beforeSrc) {
          try { URL.revokeObjectURL(beforeSrc); } catch {}
        }
      }
    }

    btn.addEventListener("click", gerar);
  </script>

</body>
</html>
